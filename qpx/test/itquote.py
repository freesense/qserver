# -*- coding: utf-8 -*-import sys, threading, socket, struct, string, time, random, binaryoutput, packetqmarketdict = {4097 : u'上证指数', \              4098 : u'上证债券', \              4099 : u'上证基金', \              4100 : u'上证Ａ股', \              4101 : u'上证Ｂ股', \              4102 : u'上证其它', \              4113 : u'深证指数', \              4114 : u'深证债券', \              4115 : u'深证基金', \              4116 : u'深证Ａ股', \              4117 : u'深证Ｂ股', \              4118 : u'深证其它', \              8196 : u'香港股市'}sortdict = {0x0801 : u'涨幅排行榜',\            0x0802 : u'振幅排行榜',\            0x0803 : u'量比排行榜',\            0x0804 : u'金额排行榜',\            0x0805 : u'委比排行榜',\            0x0806 : u'成交量排行榜'}class itquote_trd(threading.Thread):    def __init__(self, threadname, peer, cmds = [], mode = 0):  #mode:0-打印接收到的数据，1-返回接收到的数据        self.sock = None        self.peer = peer        self.cmds = cmds        self.mode = mode        self._time = 0        self.status = 0        self.rbuffer = ''        self.httpidx = 0        self.bAnswer = True        self.callDict = {0x0a00 : self.onVerify, \                         0x1000 : self.onInitMarket, \                         0x0400 : self.onReal, \                         0x0B00 : self.onNewReal, \                         0x0F00 : self.onOverlapReal, \                         0x0d00 : self.onReal2, \                         0x0100 : self.onTrace, \                         0x0600 : self.onKLine, \                         0x0800 : self.onSort, \                         0x1200 : self.onF10, \                         0x1600 : self.onAllStat, \                         0x0300 : self.onSymbolStatus, \                         0x0200 : self.onSort, \                         0x1700 : self.onTxSelect, \                         0x0c00 : self.onTextInfo}        threading.Thread.__init__(self, name = threadname)            def read(self):        if self.sock is None:            return ''        try:            self.rbuffer += self.sock.recv(8192)        except socket.error, (errno, strerror):            print 'Read socket error:', errno, strerror            self.sock.close()            sys.exit(1)        if self.status == 0:            self.httpidx = self.rbuffer.find('\r\n\r\n')            if -1 != self.httpidx:                self.rbuffer = self.rbuffer[self.httpidx+4:]                self.status = 1        if self.status == 1:            if len(self.rbuffer) >= 8:                self.status = 2        if self.status == 2:            size, unuse = struct.unpack_from("!ii", self.rbuffer)            if len(self.rbuffer) >= size + 8:                return self.rbuffer        return ''    def send(self, buf):        self._time = time.clock()        try:           self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)           self.sock.connect(self.peer)           print u'Connect:', time.clock() - self._time           self._time = time.clock()           self.sock.send(buf)           if len(self.cmds) == 0:                data = True                while data == True:                    data = self.Receive()                    time.sleep(0.1)                return data        except socket.error, (errno, strerror):            print 'Send socket error:', errno, strerror            self.sock.close()            sys.exit(1)    def onUnknown(self, data):        print '>>>', __name__, u'未知业务'        if binaryoutput.gSwitchHexdump == False:            binaryoutput.gSwitchHexdump = True            binaryoutput.hexdump(data, len(data))            binaryoutput.gSwitchHexdump = False    def onInitMarket(self, data):        fmt = '!c2HI'        data = data[struct.calcsize(fmt)]        print '>>>', data.decode('utf_16_le')    def onVerify(self, data):        fmt1 = '!c2Hc'        fmt2 = '!H12s12s12s'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        for i in xrange(ord(items[3])):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '\t', items[0], items[1].decode('utf_16_le'), items[2].decode('utf_16_le'), items[3].decode('utf_16_le')        print u'\t代码校验完毕'    def onReal2(self, data):        fmt1 = '!c3H12s12s12si5Hc40s'        fmt2 = '!c9I'        fmt3 = 'B'        items = struct.unpack_from(fmt1, data)        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le')        print '>>>', str(items[12])        data = data[struct.calcsize(fmt1):]        for i in xrange(items[12]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '  ', i, u'时间:', str(items[1]), u'价:', str(items[2]), u'量:', str(items[4]), u'委买:', str(items[8]), u'委卖:', str(items[7])        items = struct.unpack_from(fmt3, data)        data = data[struct.calcsize(fmt3):]        print '>>>', u'今日', items[0], u'条数据'        for i in xrange(items[0]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '  ', i, u'时间:', str(items[1]), u'价:', str(items[2]), u'量:', str(items[4]), u'委买:', str(items[8]), u'委卖:', str(items[7])    def onReal(self, data):        fmt1 = '!c3H12s12s12si5Hc40s'        fmt2 = '!c9I'        items = struct.unpack_from(fmt1, data)        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le')        print u'返回', str(items[12]), u'条记录'        data = data[struct.calcsize(fmt1):]        for i in xrange(items[12]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '\t', u'时间:', str(items[1]), u'价:', str(items[2]), u'量:', str(items[4]), u'委买:', str(items[8]), u'委卖:', str(items[7])        def onNewReal(self, data):        fmt1 = '!c3H12s12s12si5Hc40s'        fmt2 = '!c9I'        items = struct.unpack_from(fmt1, data)        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le')        print u'返回', str(items[12]), u'条记录'        data = data[struct.calcsize(fmt1):]        for i in xrange(items[12]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '\t', u'时间:', str(items[1]), u'价:', str(items[2]), u'量:', str(items[4]), u'委买:', str(items[8]), u'委卖:', str(items[7])              def onOverlapReal(self, data):        fmt1 = '!c3H12s12s12si5Hc40s'        fmt2 = '!c9I'        items = struct.unpack_from(fmt1, data)        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le')        print u'返回', str(items[12]), u'条记录'        data = data[struct.calcsize(fmt1):]        for i in xrange(items[12]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '\t', u'时间:', str(items[1]), u'价:', str(items[2]), u'量:', str(items[4]), u'委买:', str(items[8]), u'委卖:', str(items[7])                      
    def onSymbolStatus(self, data):        fmt1 = '!c3H'        fmt2 = '!12s12s12sIB'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        market_name = marketdict.get(items[3], u'未知市场')        items = struct.unpack_from(fmt2, data)        print '>>>', market_name, items[0].decode('utf_16_le'), items[1].decode('utf_16_le'), items[2].decode('utf_16_le'), u'昨收:', items[3]        data = data[struct.calcsize(fmt2):]        columns = []        for i in xrange(items[4]):            title = data.split('|', 1)[0]            data = data[len(title) + 1:]            columns.append(title)            data = data[1:]        fmt3 = '!B'        data = data[struct.calcsize(fmt3):]        fmt4 = '!I'        for i in xrange(items[4]):            print '\t', columns[i].decode('utf_16_le'), struct.unpack_from(fmt4, data)[0]            data = data[struct.calcsize(fmt4):]    def onAllStat(self, data):        fmt1 = '!c3H'        fmt2 = '!HI12s32I'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        print '>>>', u'共返回', items[3], u'记录'        print u'市场'.rjust(5), u'代码'.rjust(15), u'名称'.rjust(10), u'昨收'.rjust(15), u'今开'.rjust(15)        for i in xrange(items[3]):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print str(items[0]).rjust(5), str(items[1]).rjust(15), items[2].decode('utf_16_le').rjust(10), str(items[3]).rjust(15), str(items[4]).rjust(15)    def onTrace(self, data):        fmt1 = '!c3H12s12s12sicH'        fmt2 = '!cH5I'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le'), items[6].decode('utf_16_le'), u'昨收:', str(items[7])        ucTitles = ord(items[8])        ucUnits = items[9]        for i in xrange(ucTitles):            title = data.split('|', 1)[0]            data = data[len(title) + 1:]            print '\t', 'Title:', title.decode('utf_16_le'), ord(data[0])            data = data[1:]        for i in xrange(ucUnits):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '\t', u'时间:', str(items[1]), u'成交价:', str(items[2])    def onKLine(self, data):        fmt1 = '!c3H12s12s12sc'        fmt2 = '!H'        fmt3 = '!c6I'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        print '>>>', marketdict.get(items[3], u'未知市场'), items[4].decode('utf_16_le'), items[5].decode('utf_16_le')        ucTitles = ord(items[7])        for i in xrange(ucTitles):            title = data.split('|', 1)[0]            data = data[len(title) + 1:]            print '\t', 'Title:', title.decode('utf_16_le'), ord(data[0])            data = data[1:]        items = struct.unpack_from(fmt2, data)        data = data[struct.calcsize(fmt2):]        ucUnits = items[0]        for i in xrange(ucUnits):            items = struct.unpack_from(fmt3, data)            data = data[struct.calcsize(fmt3):]            print '\t', items[1], u'开:', items[2], u'高:', items[3], u'低:', items[4], u'收:', items[5], u'量:', items[6]    def onSort(self, data):        fmt1 = '!c4Hc'        fmt2 = '!cH12s12s12s11I'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        ucUnits = items[3]        ucStock = items[4]        ucTitles = items[5]        titles = []        for i in xrange(ord(ucTitles)):            title = data.split('|', 1)[0]            titles.append(title)            data = data[len(title) + 2:]        for i in xrange(ucUnits):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '>>>', marketdict.get(items[1], u'未知市场'), items[2].decode('utf_16_le'), items[3].decode('utf_16_le'), items[4].decode('utf_16_le')            for j in xrange(ord(ucTitles)):                print '\t', titles[j].decode('utf_16_le'), items[5+j]    def onTxSelect(self, data):        fmt1 = '!c3H'        fmt2 = '!HI12s32I'        items = struct.unpack_from(fmt1, data)        data = data[struct.calcsize(fmt1):]        while len(data) >= struct.calcsize(fmt2):            items = struct.unpack_from(fmt2, data)            data = data[struct.calcsize(fmt2):]            print '>>>', marketdict.get(items[0], u'未知市场'), items[2].decode('utf_16_le')            print u'昨收'.ljust(6), str(items[3]).rjust(11), u'今开'.ljust(6), str(items[4]).rjust(11)            print u'最高'.ljust(6), str(items[5]).rjust(11), u'最低'.ljust(6), str(items[6]).rjust(11)            print u'成交量'.ljust(6), str(items[8]).rjust(10), u'金额'.ljust(6), str(items[9]).rjust(11)            print u'成交价'.ljust(6), str(items[13]).rjust(10), u'现手'.ljust(6), str(items[14]).rjust(11)            print u'外盘'.ljust(6), str(items[11]).rjust(11), u'内盘'.ljust(6), str(items[10]).rjust(11)            print u'量比'.ljust(6), str(items[12]).rjust(11), u'均价'.ljust(6), str(items[7]).rjust(11)    def onF10(self, data):        print '>>>', u'F10信息', data[9:].decode('utf_16_le')    def onTextInfo(self, data):        print '>>>', u'文本信息', data[7:].decode('utf_16_le')    def Receive(self):        data = self.read()        if len(data) == 0:            return True        size, unuse = struct.unpack_from('!ii', data)        data = data[struct.calcsize('!ii'):]        binaryoutput.hexdump(data, len(data))        element = struct.unpack_from('!cH', data)        self.sock.close()        print 'Time:', time.clock() - self._time        if self.mode == 1:            return data        elif len(self.cmds) == 0:            switchFunc = self.callDict.get((element[1] & 0xff00), self.onUnknown)            switchFunc(data)        self.rbuffer = ''        self.status = 0        self.bAnswer = True        return False    def run(self):        while len(self.cmds):            command = random.choice(self.cmds).split()            print command            buf = packetq.make_send_buffer(command)            if len(buf):                self.send(buf)                while self.Receive() == True:                    print 123456                    time.sleep(0.1)            time.sleep(random.uniform(0, 10))